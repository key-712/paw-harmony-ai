<!DOCTYPE html>
<html>
  <head>
    <title>Music Generator</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }
      .container {
        text-align: center;
        padding: 20px;
        border-radius: 8px;
        background-color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      #status {
        margin-top: 20px;
        font-size: 1.2em;
        color: #333;
      }
      .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        margin-top: 10px;
      }
      .progress-fill {
        height: 100%;
        background-color: #007bff;
        width: 0%;
        transition: width 0.3s ease;
      }
      .error-message {
        color: #dc3545;
        margin-top: 10px;
        font-size: 0.9em;
      }
      .retry-button {
        margin-top: 15px;
        padding: 8px 16px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9em;
      }
      .retry-button:hover {
        background-color: #218838;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>音楽生成中...</h1>
      <p id="status">AIモデルを初期化しています...</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progress"></div>
      </div>
      <div id="error-container" style="display: none;">
        <p class="error-message" id="error-message"></p>
        <button class="retry-button" onclick="retryMusicGeneration()">
          再試行
        </button>
      </div>
    </div>

    <script>
      // デバッグ用のログ
      console.log("Music Generator HTML loaded successfully");
      
      // 少し待ってからデバッグメッセージを送信（Tone.jsの読み込みを待つ）
      setTimeout(() => {
        sendDebugMessageImmediately("Music Generator HTML loaded successfully");
        
        // Tone.jsの読み込み確認
        if (typeof Tone === "undefined") {
          console.error("Tone.js is not loaded!");
          sendDebugMessageImmediately("ERROR: Tone.js is not loaded!");
          showError("音楽生成ライブラリの読み込みに失敗しました。");
          return;
        } else {
          console.log("Tone.js loaded successfully");
          sendDebugMessageImmediately("Tone.js loaded successfully");
        }
      }, 100);

      // 音楽生成の状態管理
      let isModelInitialized = false;
      let currentGenerationRequest = null;
      let retryCount = 0;
      const MAX_RETRY_COUNT = 3;
      
      // 初期化状態を確実に管理する関数
      function setModelInitialized(value) {
        isModelInitialized = value;
        window.isModelInitialized = value; // グローバル変数も更新
        console.log(`Model initialization status set to: ${value}`);
        sendDebugMessageImmediately(`Model initialization status set to: ${value}`);
      }

      // Flutterアプリにデバッグメッセージを送信
      setTimeout(() => {
        sendDebugMessageImmediately("Music Generator initialized");
      }, 200);

      // エラー表示関数
      function showError(message) {
        const errorContainer = document.getElementById("error-container");
        const errorMessage = document.getElementById("error-message");
        const status = document.getElementById("status");
        
        errorMessage.textContent = message;
        errorContainer.style.display = "block";
        status.textContent = "エラーが発生しました";
        updateProgress(0);
      }

      // エラーを隠す関数
      function hideError() {
        const errorContainer = document.getElementById("error-container");
        errorContainer.style.display = "none";
      }

      // プログレスバーの更新
      function updateProgress(percentage) {
        const progressBar = document.getElementById("progress");
        if (progressBar) {
          progressBar.style.width = percentage + "%";
        }
      }

      // AudioBufferをWAV形式のBlobに変換するヘルパー関数（iOS対応版）
      function bufferToWave(abuffer) {
        const numOfChan = abuffer.numberOfChannels;
        const sampleRate = 44100; // 標準的なサンプリングレートを使用
        const length = abuffer.length * numOfChan * 2 + 44;
        const buffer = new ArrayBuffer(length);
        const view = new DataView(buffer);
        const channels = [];
        let pos = 0;

        console.log('Converting buffer to WAV:', {
          channels: numOfChan,
          length: abuffer.length,
          sampleRate: abuffer.sampleRate,
          targetSampleRate: sampleRate
        });

        // WAVEヘッダーを書き込む（iOS対応）
        // "RIFF" (リトルエンディアン)
        view.setUint32(pos, 0x52494646, false);
        pos += 4;
        // ファイル長 - 8
        view.setUint32(pos, length - 8, true);
        pos += 4;
        // "WAVE" (リトルエンディアン)
        view.setUint32(pos, 0x45564157, false);
        pos += 4;
        // "fmt " (リトルエンディアン)
        view.setUint32(pos, 0x20746d66, false);
        pos += 4;
        // チャンク長
        view.setUint32(pos, 16, true);
        pos += 4;
        // フォーマットID (PCM)
        view.setUint16(pos, 1, true);
        pos += 2;
        // チャンネル数
        view.setUint16(pos, numOfChan, true);
        pos += 2;
        // サンプリングレート
        view.setUint32(pos, sampleRate, true);
        pos += 4;
        // データ速度
        view.setUint32(pos, sampleRate * 2 * numOfChan, true);
        pos += 4;
        // ブロックサイズ
        view.setUint16(pos, numOfChan * 2, true);
        pos += 2;
        // サンプルあたりのビット数
        view.setUint16(pos, 16, true);
        pos += 2;
        // "data" (リトルエンディアン)
        view.setUint32(pos, 0x61746164, false);
        pos += 4;
        // データ長
        view.setUint32(pos, abuffer.length * numOfChan * 2, true);
        pos += 4;

        // ヘッダー情報をログ出力
        console.log('WAV Header Info:', {
          riff: 'RIFF',
          fileSize: length - 8,
          wave: 'WAVE',
          fmt: 'fmt ',
          fmtSize: 16,
          audioFormat: 1,
          channels: numOfChan,
          sampleRate: sampleRate,
          byteRate: sampleRate * 2 * numOfChan,
          blockAlign: numOfChan * 2,
          bitsPerSample: 16,
          data: 'data',
          dataSize: abuffer.length * numOfChan * 2
        });
        
        // iOS互換性のための追加チェック
        console.log('iOS compatibility check:');
        console.log('- Sample rate: 44.1kHz (standard)');
        console.log('- Bit depth: 16-bit (standard)');
        console.log('- Channels: ' + numOfChan + ' (mono/stereo)');
        console.log('- Format: PCM (uncompressed)');

        // チャンネルデータを取得
        for (let i = 0; i < abuffer.numberOfChannels; i++) {
          channels.push(abuffer.getChannelData(i));
        }

        // PCMデータを書き込む（サンプリングレート変換なし）
        for (let i = 0; i < abuffer.length; i++) {
          for (let j = 0; j < numOfChan; j++) {
            let sample = Math.max(-1, Math.min(1, channels[j][i]));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
            view.setInt16(pos, sample, true);
            pos += 2;
          }
        }

        console.log('WAV conversion completed. Final position:', pos);
        
        // WAV形式でBlobを作成（正しいMIMEタイプ）
        return new Blob([view], { type: "audio/wav" });
      }

      // 犬の品種に基づく音楽特性の定義
      const breedMusicCharacteristics = {
        ゴールデンレトリバー: {
          tempo: 120,
          key: "C",
          mood: "happy",
          instruments: ["piano", "strings"],
          complexity: "medium",
        },
        ラブラドールレトリバー: {
          tempo: 115,
          key: "G",
          mood: "friendly",
          instruments: ["piano", "bass"],
          complexity: "medium",
        },
        柴犬: {
          tempo: 140,
          key: "D",
          mood: "energetic",
          instruments: ["synth", "drums"],
          complexity: "high",
        },
        トイプードル: {
          tempo: 100,
          key: "F",
          mood: "gentle",
          instruments: ["flute", "harp"],
          complexity: "low",
        },
        チワワ: {
          tempo: 110,
          key: "A",
          mood: "playful",
          instruments: ["bells", "piano"],
          complexity: "low",
        },
        パグ: {
          tempo: 95,
          key: "Bb",
          mood: "relaxed",
          instruments: ["strings", "piano"],
          complexity: "medium",
        },
        シベリアンハスキー: {
          tempo: 130,
          key: "E",
          mood: "adventurous",
          instruments: ["synth", "drums"],
          complexity: "high",
        },
        フレンチブルドッグ: {
          tempo: 105,
          key: "C",
          mood: "charming",
          instruments: ["piano", "bass"],
          complexity: "medium",
        },
      };

      // 性格特性に基づく音楽調整
      function adjustMusicForPersonality(characteristics, baseCharacteristics) {
        let adjusted = { ...baseCharacteristics };
        characteristics.forEach((trait) => {
          switch (trait) {
            case "活発":
              adjusted.tempo += 10;
              break;
            case "落ち着き":
              adjusted.tempo -= 15;
              break;
            case "遊び好き":
              adjusted.tempo += 15;
              break;
          }
        });
        return adjusted;
      }

      // シーンに基づく音楽調整
      function adjustMusicForScenario(scenario, baseCharacteristics) {
        let adjusted = { ...baseCharacteristics };
        switch (scenario) {
          case "留守番中":
            adjusted.mood = "calming";
            break;
          case "就寝前":
            adjusted.mood = "soothing";
            break;
          case "ストレスフル":
            adjusted.mood = "relaxing";
            break;
        }
        return adjusted;
      }

      // 音楽生成の再試行関数
      function retryMusicGeneration() {
        if (currentGenerationRequest && retryCount < MAX_RETRY_COUNT) {
          retryCount++;
          hideError();
          document.getElementById("status").textContent = `音楽生成を再試行中... (${retryCount}/${MAX_RETRY_COUNT})`;
          updateProgress(0);
          
          setTimeout(() => {
            generateActualMusic(
              currentGenerationRequest.dogBreed,
              currentGenerationRequest.dogPersonalityTraits,
              currentGenerationRequest.scenario
            );
          }, 1000);
        } else {
          showError("最大再試行回数に達しました。しばらく時間をおいてから再度お試しください。");
        }
      }

      // 実際の音楽生成関数
      async function generateActualMusic(
        dogBreed,
        dogPersonalityTraits,
        scenario
      ) {
        try {
          console.log("=== generateActualMusic started ===");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage("=== generateActualMusic started ===");
          }
          
          hideError();
          updateProgress(10);
          document.getElementById("status").textContent = "音楽を生成しています...";

          const baseCharacteristics =
            breedMusicCharacteristics[dogBreed] ||
            breedMusicCharacteristics["ゴールデンレトリバー"];
          let musicCharacteristics = adjustMusicForPersonality(
            dogPersonalityTraits,
            baseCharacteristics
          );
          musicCharacteristics = adjustMusicForScenario(
            scenario,
            musicCharacteristics
          );

          console.log("Music characteristics:", musicCharacteristics);
          if (window.DebugChannel) {
            window.DebugChannel.postMessage(
              `Music characteristics: ${JSON.stringify(musicCharacteristics)}`
            );
          }
          updateProgress(30);

          const duration = 30; // 30秒間の音楽を生成

          // Tone.jsの初期化を確実に行う
          console.log("Starting Tone.js...");
          await Tone.start();
          console.log("Tone.js started successfully");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage("Tone.js started successfully");
          }

          // より確実な音楽生成処理
          let buffer;
          try {
            console.log("Starting offline rendering...");
            // タイムアウト処理を追加
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(
                () => reject(new Error("音楽生成がタイムアウトしました")),
                45000
              ); // 45秒タイムアウト（30秒の音楽生成 + 余裕）
            });

            const offlinePromise = Tone.Offline(async ({ transport }) => {
              console.log("Offline rendering callback started");
              // サンプリングレートを44.1kHzに設定（標準的な音質）
              Tone.context.sampleRate = 44100;
              try {
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage("Starting offline rendering...");
                }

                // 複数の楽器を使用してより豊かな音楽を生成
                console.log("Creating instruments...");
                const synth = new Tone.Synth({
                  oscillator: {
                    type: "sine",
                  },
                  envelope: {
                    attack: 0.1,
                    decay: 0.2,
                    sustain: 0.3,
                    release: 0.8,
                  },
                }).toDestination();

                const bass = new Tone.MonoSynth({
                  oscillator: {
                    type: "square",
                  },
                  envelope: {
                    attack: 0.1,
                    decay: 0.3,
                    sustain: 0.4,
                    release: 1.0,
                  },
                }).toDestination();

                console.log("Instruments created successfully");
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage("Instruments created successfully");
                }

                // メロディーラインを生成（30秒用に拡張）
                const melodyNotes = ["C4", "E4", "G4", "C5", "E5", "G5", "C4", "F4", "A4", "C5", "F5", "A5"];
                const bassNotes = ["C2", "G2", "C3", "G3", "F2", "C3", "F3", "C4"];

                console.log("Scheduling melody notes...");
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage("Scheduling melody notes...");
                }

                // メロディーを演奏（30秒間繰り返し）
                for (let repeat = 0; repeat < 6; repeat++) {
                  melodyNotes.forEach((note, index) => {
                    synth.triggerAttackRelease(note, "4n", `+${repeat * 5 + index * 0.4}`);
                  });
                }

                // ベースラインを演奏（30秒間繰り返し）
                for (let repeat = 0; repeat < 6; repeat++) {
                  bassNotes.forEach((note, index) => {
                    bass.triggerAttackRelease(note, "2n", `+${repeat * 5 + index * 0.6}`);
                  });
                }

                console.log("Notes scheduled, starting transport...");
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage("Starting transport...");
                }

                // 30秒間の音楽を生成
                transport.start();
                transport.stop("+30");

                console.log("Transport started and scheduled to stop");
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage("Transport started and scheduled to stop");
                }
              } catch (error) {
                if (window.DebugChannel) {
                  window.DebugChannel.postMessage(`Error in offline rendering: ${error.message}`);
                }
                throw error;
              }
            }, 30); // 30秒間のレンダリング

            // タイムアウトとオフライン処理を競合させる
            buffer = await Promise.race([offlinePromise, timeoutPromise]);
          } catch (error) {
            if (window.DebugChannel) {
              window.DebugChannel.postMessage(`Tone.Offline failed: ${error.message}`);
            }
            throw new Error(`音楽生成に失敗しました: ${error.message}`);
          }

          if (window.DebugChannel) {
            window.DebugChannel.postMessage("Offline rendering complete.");
          }
          console.log("Offline rendering complete");
          updateProgress(70);

          if (window.DebugChannel) {
            window.DebugChannel.postMessage(
              `Buffer created: ${buffer.length} samples, ${buffer.numberOfChannels} channels, ${buffer.sampleRate}Hz`
            );
          }
          console.log(`Buffer created: ${buffer.length} samples, ${buffer.numberOfChannels} channels, ${buffer.sampleRate}Hz`);

          // AudioBufferをWAV Blobに変換
          console.log("Converting buffer to WAV...");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage("Converting buffer to WAV...");
          }

          const wavBlob = bufferToWave(buffer);
          console.log("WAV blob created");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage("WAV blob created.");
          }

          // WAVファイルのサイズをログ出力
          console.log("WAV blob size:", wavBlob.size, "bytes");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage(`WAV blob size: ${wavBlob.size} bytes`);
          }

          // BlobをBase64に変換
          console.log("Converting WAV to Base64...");
          if (window.DebugChannel) {
            window.DebugChannel.postMessage("Converting WAV to Base64...");
          }

          const reader = new FileReader();
          reader.readAsDataURL(wavBlob);
          reader.onloadend = () => {
            const audioDataUrl = reader.result;
            console.log("Base64 conversion complete");
            if (window.DebugChannel) {
              window.DebugChannel.postMessage("Base64 conversion complete.");
            }
            updateProgress(90);

            const musicData = {
              type: "generated_music",
              data: audioDataUrl,
              message: "音楽生成完了",
              musicInfo: { ...musicCharacteristics, duration, format: "wav", mimeType: "audio/wav" },
            };

            console.log("Sending music data to Flutter...");
            if (window.MusicGeneratedChannel) {
              window.MusicGeneratedChannel.postMessage(
                JSON.stringify(musicData)
              );
              console.log("Music data sent to Flutter successfully");
              if (window.DebugChannel) {
                window.DebugChannel.postMessage("Music data sent to Flutter.");
              }
              console.log("Music generation completed successfully");

              // 少し待ってから状態を更新
              setTimeout(() => {
                document.getElementById("status").innerText = "音楽生成が完了しました！";
                updateProgress(100);
                retryCount = 0; // 成功時にリトライカウントをリセット
              }, 1000);
            } else {
              console.error("MusicGeneratedChannel not available");
              if (window.DebugChannel) {
                window.DebugChannel.postMessage("ERROR: MusicGeneratedChannel not available");
              }
              throw new Error("音楽データの送信に失敗しました");
            }
          };
          reader.onerror = (error) => {
            if (window.DebugChannel) {
              window.DebugChannel.postMessage(`FileReader error: ${error}`);
            }
            throw new Error("音楽ファイルの変換に失敗しました");
          };
        } catch (error) {
          if (window.DebugChannel) {
            window.DebugChannel.postMessage(`ERROR in generateActualMusic: ${error.message}`);
          }
          
          // エラーを表示
          showError(error.message);
          
          if (window.MusicGenerationErrorChannel) {
            window.MusicGenerationErrorChannel.postMessage(error.message);
          }
        }
      }

      // AIモデルの初期化
      async function initializeAIModel() {
        try {
          console.log("Starting AI model initialization...");
          sendDebugMessageImmediately("Initializing AI model...");
          
          document.getElementById("status").textContent = "AIモデルを初期化しています...";
          updateProgress(20);

          // Tone.jsの初期化
          console.log("Initializing Tone.js...");
          await Tone.start();
          
          sendDebugMessageImmediately("Tone.js initialized successfully");
          console.log("Tone.js initialized successfully");
          
          updateProgress(50);

          // 音楽生成パラメータの初期化
          console.log("Initializing music generation parameters...");
          const testSynth = new Tone.Synth().toDestination();
          testSynth.dispose(); // テスト用のシンセを破棄
          
          sendDebugMessageImmediately("Music generation parameters initialized");
          console.log("Music generation parameters initialized");
          
          updateProgress(80);

          // 初期化完了
          console.log("AI model initialization completed");
          sendDebugMessageImmediately("AI model initialization completed");
          
          document.getElementById("status").textContent = "AIモデルの初期化が完了しました";
          updateProgress(100);
          
          window.isInitialized = true;
          window.isInitializing = false;
          setModelInitialized(true); // 専用関数を使用して確実に更新
          
          sendDebugMessageImmediately("AI model is ready for music generation");
          sendDebugMessageImmediately(`isModelInitialized set to: ${isModelInitialized}`);
          sendDebugMessageImmediately(`window.isModelInitialized set to: ${window.isModelInitialized}`);
          
          // 初期化完了時にFlutterReadyChannelを送信
          trySendFlutterReadyMessage();
          
          // 3秒後に初期化完了メッセージを消す
          setTimeout(() => {
            document.getElementById("status").textContent = "音楽生成の準備が完了しました";
          }, 3000);
          
        } catch (error) {
          console.error("AI model initialization failed:", error);
          sendDebugMessageImmediately(`AI model initialization failed: ${error.message}`);
          setModelInitialized(false); // エラー時は初期化状態をfalseに
          showError(`AIモデルの初期化に失敗しました: ${error.message}`);
        }
      }

      // FlutterReadyChannelを送信する関数
      function sendFlutterReadyMessage() {
        if (window.FlutterReadyChannel) {
          window.FlutterReadyChannel.postMessage("flutter_ready");
          console.log("FlutterReadyChannel: flutter_ready sent");
          return true;
        } else {
          console.error("FlutterReadyChannel is not defined.");
          return false;
        }
      }

      // 複数回試行してFlutterReadyChannelを確実に送信
      function trySendFlutterReadyMessage() {
        let attempts = 0;
        const maxAttempts = 5; // 試行回数を削減
        const interval = 500; // 間隔を延長
        
        function attempt() {
          if (attempts >= maxAttempts) {
            console.error("FlutterReadyChannel: Max attempts reached");
            return;
          }
          
          if (!sendFlutterReadyMessage()) {
            attempts++;
            setTimeout(attempt, interval);
          } else {
            // 送信成功後は追加送信を削減
            setTimeout(() => {
              sendFlutterReadyMessage();
            }, 2000);
          }
        }
        
        attempt();
      }

      // 即座にFlutterReadyChannelを送信する関数
      function sendFlutterReadyImmediately() {
        console.log("Sending FlutterReadyChannel immediately...");
        sendFlutterReadyMessage();
        
        // 送信回数を削減
        setTimeout(() => {
          sendFlutterReadyMessage();
        }, 1000);
        
        setTimeout(() => {
          sendFlutterReadyMessage();
        }, 3000);
      }

      // グローバル関数を即座に定義
      window.updateProgress = updateProgress;
      window.initializeAIModel = initializeAIModel;
      window.showError = showError;
      window.retryMusicGeneration = retryMusicGeneration;
      window.generateActualMusic = generateActualMusic;

      // 初期化状態を管理
      window.isInitializing = false;
      window.isInitialized = false;
      window.isModelInitialized = false; // 追加
      
      // 初期化状態を確実にリセット
      setModelInitialized(false);

      // メッセージリスナーの設定を即座に行う
      console.log('Setting up message listener for Flutter communication...');
      
      // メッセージリスナーが正しく設定されているか確認
      if (window.addEventListener) {
        console.log('addEventListener is available');
      } else {
        console.error('addEventListener is not available');
      }
      
      // 即座にテストメッセージを送信
      setTimeout(() => {
        sendDebugMessageImmediately('Initial debug message test');
      }, 150);
              setTimeout(() => {
          sendDebugMessageImmediately('Setting up message listener for Flutter communication...');
        }, 250);

      // DebugChannelの初期化を確認する関数
      function checkDebugChannelAvailability() {
        console.log('Checking DebugChannel availability...');
        if (window.DebugChannel) {
          console.log('DebugChannel is available');
          sendDebugMessageImmediately('DebugChannel is available and working');
          return true;
        } else {
          console.log('DebugChannel is not available');
          return false;
        }
      }

              // 定期的にDebugChannelの利用可能性をチェック
        setInterval(() => {
          checkDebugChannelAvailability();
        }, 2000);
        
        // 定期的なデバッグメッセージ送信を開始
        checkDebugChannelPeriodically();

      // DebugChannelの利用可能性をチェックしてメッセージを送信する関数
      function sendDebugMessage(message) {
        try {
          if (window.DebugChannel) {
            window.DebugChannel.postMessage(message);
            console.log('DebugChannel sent:', message);
            return true;
          } else {
            console.log('DebugChannel not available');
            return false;
          }
        } catch (error) {
          console.error('Error sending debug message:', error);
          return false;
        }
      }
      
      // DebugChannelの利用可能性を定期的にチェック
      function checkDebugChannelPeriodically() {
        setInterval(() => {
          if (window.DebugChannel) {
            sendDebugMessage('DebugChannel periodic check: available');
          } else {
            console.log('DebugChannel periodic check: not available');
          }
        }, 3000); // 3秒ごとにチェック
      }

      // DebugChannelが利用可能になるまで待機してメッセージを送信
      function sendDebugMessageWithRetry(message, maxAttempts = 20) {
        let attempts = 0;
        
        function attempt() {
          if (attempts >= maxAttempts) {
            console.error('DebugChannel: Max attempts reached for message:', message);
            return;
          }
          
          if (!sendDebugMessage(message)) {
            attempts++;
            setTimeout(attempt, 100);
          }
        }
        
        // 即座に試行開始
        attempt();
      }

      // 即座にDebugChannelメッセージを送信する関数
      function sendDebugMessageImmediately(message) {
        console.log('Attempting to send debug message immediately:', message);
        
        // 即座に送信
        sendDebugMessage(message);
        
        // 複数回送信して確実に届くようにする
        setTimeout(() => {
          sendDebugMessage(message);
        }, 50);
        
        setTimeout(() => {
          sendDebugMessage(message);
        }, 100);
        
        setTimeout(() => {
          sendDebugMessage(message);
        }, 200);
        
        setTimeout(() => {
          sendDebugMessage(message);
        }, 500);
        
        setTimeout(() => {
          sendDebugMessage(message);
        }, 1000);
      }

      // Flutterから呼び出される初期化のエントリーポイント
      function startInitialization() {
        console.log("startInitialization() called from Flutter");
        sendDebugMessageImmediately("startInitialization() called from Flutter.");
        
        // 即座にFlutterReadyChannelを送信
        sendFlutterReadyImmediately();
        
        if (!window.isInitializing && !window.isInitialized) {
          window.isInitializing = true;
          
          sendDebugMessageImmediately("Starting AI model initialization...");
          
          // 初期化開始時にFlutterReadyChannelを送信
          trySendFlutterReadyMessage();
          
          initializeAIModel();
        } else {
          console.log("Already initializing or initialized");
          sendDebugMessageImmediately("Already initializing or initialized");
          // 既に初期化済みの場合は即座にFlutterReadyChannelを送信
          trySendFlutterReadyMessage();
        }
      }
      
      // グローバル関数として定義
      window.startInitialization = startInitialization;
      
      // 関数が利用可能かどうかを確認
      console.log("startInitialization function defined:", typeof window.startInitialization);

      setTimeout(() => {
        sendDebugMessageImmediately("JavaScript functions defined and ready for Flutter.");
      }, 300);

      // FlutterにJavaScriptの準備が完了したことを通知
      function sendReadyMessage() {
        if (window.JavaScriptReadyChannel) {
          window.JavaScriptReadyChannel.postMessage('ready');
          console.log('JavaScriptReadyChannel: ready message sent');
          return true;
        } else {
          console.error('JavaScriptReadyChannel is not defined.');
          return false;
        }
      }

      // 複数回試行してJavaScriptチャンネルを確実に送信
      let readyAttempts = 0;
      const maxReadyAttempts = 5;
      
      function trySendReadyMessage() {
        if (readyAttempts >= maxReadyAttempts) {
          console.error('JavaScriptReadyChannel: Max attempts reached');
          return;
        }
        
        if (!sendReadyMessage()) {
          readyAttempts++;
          setTimeout(trySendReadyMessage, 500);
        }
      }
      
      // DOMContentLoadedイベントで初期化を開始
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded event fired');
        
        // 即座にデバッグメッセージを送信（複数回）
        sendDebugMessageImmediately('DOMContentLoaded: HTML loaded successfully');
        
        // 1秒後に再度デバッグメッセージを送信
        setTimeout(() => {
          sendDebugMessageImmediately('DOMContentLoaded: Second debug message');
        }, 1000);
        
        // DebugChannelの利用可能性を即座にチェック
        checkDebugChannelAvailability();
        
        // メッセージリスナーの設定をログに出力
        console.log('Message listener is ready to receive messages from Flutter');
        sendDebugMessageImmediately('Message listener is ready to receive messages from Flutter');
        
        // 即座にFlutterReadyChannelを送信
        sendFlutterReadyImmediately();
        
        // 少し待ってからチャンネルの初期化を開始
        setTimeout(() => {
          console.log('Starting channel initialization...');
          
          // デバッグメッセージを再送信
          sendDebugMessageImmediately('Channel initialization started');
          
          // DebugChannelの利用可能性を再チェック
          checkDebugChannelAvailability();
          
          // テストチャンネルを送信
          if (window.TestChannel) {
            window.TestChannel.postMessage('test_message');
            console.log('TestChannel: test_message sent');
          } else {
            console.error('TestChannel is not defined.');
          }
          
          // 即座に試行開始
          trySendReadyMessage();
          
          // 初期化完了時にFlutterReadyChannelを送信する準備
          // この時点ではまだ初期化が完了していないので、初期化完了時に送信される
        }, 100);
      });
      
      // スクリプト読み込み完了時にもデバッグメッセージを送信
      window.addEventListener('load', function() {
        console.log('Window load event fired');
        sendDebugMessageImmediately('Window load event: All resources loaded');
      });

      // Flutterからのメッセージを受信
      window.addEventListener("message", async (event) => {
        console.log("Received message:", event.data);
        
        // 即座にデバッグメッセージを送信（複数回）
        sendDebugMessageImmediately(`Received message: ${JSON.stringify(event.data)}`);

        // メッセージの詳細をログに出力
        if (event.data) {
          console.log("Message type:", event.data.type);
          console.log("Message payload:", event.data.payload);
          sendDebugMessageImmediately(`Message type: ${event.data.type}`);
          if (event.data.payload) {
            sendDebugMessageImmediately(`Message payload: ${JSON.stringify(event.data.payload)}`);
          }
        }

        // メッセージの種類に応じた処理
        if (event.data && event.data.type === "generateMusic") {
          console.log("Music generation request received");
          sendDebugMessageImmediately("Music generation request received");
          
          console.log("Checking model initialization status:", {
            isModelInitialized,
            windowIsInitialized: window.isInitialized,
            windowIsInitializing: window.isInitializing,
            windowIsModelInitialized: window.isModelInitialized
          });
          sendDebugMessageImmediately(`Model status check: isModelInitialized=${isModelInitialized}, window.isInitialized=${window.isInitialized}, window.isModelInitialized=${window.isModelInitialized}, isReady=${isModelInitialized || window.isInitialized || window.isModelInitialized}`);
          
          // 複数の初期化状態をチェック
          const isReady = isModelInitialized || window.isInitialized || window.isModelInitialized;
          
          if (!isReady) {
            console.error("Model not ready for generation");
            sendDebugMessageImmediately("ERROR: Model not ready for generation");
            
            // 初期化が完了していない場合は、自動的に初期化を開始
            if (!window.isInitializing && !window.isInitialized) {
              console.log("Starting initialization automatically...");
              sendDebugMessageImmediately("Starting initialization automatically...");
              window.isInitializing = true;
              initializeAIModel().then(() => {
                // 初期化完了後に音楽生成を再実行
                console.log("Initialization completed, retrying music generation...");
                sendDebugMessageImmediately("Initialization completed, retrying music generation...");
                generateActualMusic(dogBreed, dogPersonalityTraits, scenario);
              }).catch((error) => {
                console.error("Auto-initialization failed:", error);
                sendDebugMessageImmediately(`Auto-initialization failed: ${error.message}`);
                showError("AIモデルの初期化に失敗しました。しばらくお待ちください。");
              });
            } else {
              showError("AIモデルがまだ初期化されていません。しばらくお待ちください。");
            }
            return;
          }

          const { dogBreed, dogPersonalityTraits, scenario } = event.data.payload;

          console.log("Starting music generation with:", {
            dogBreed,
            dogPersonalityTraits,
            scenario,
          });
          
          sendDebugMessageImmediately(
            `Starting music generation: breed=${dogBreed}, traits=${dogPersonalityTraits}, scenario=${scenario}`
          );

          // 現在のリクエストを保存（再試行用）
          currentGenerationRequest = {
            dogBreed,
            dogPersonalityTraits,
            scenario
          };

          document.getElementById("status").textContent = "音楽を生成しています...";
          updateProgress(0);
          hideError();

          try {
            await generateActualMusic(dogBreed, dogPersonalityTraits, scenario);
          } catch (error) {
            console.error("Error in music generation:", error);
            sendDebugMessageImmediately(`Error in music generation: ${error.message}`);
            if (window.MusicGenerationErrorChannel) {
              window.MusicGenerationErrorChannel.postMessage(error.message);
            }
          }
        } else {
          console.log("Received message but not a music generation request:", event.data);
          sendDebugMessageImmediately(`Received non-music message: ${JSON.stringify(event.data)}`);
        }
      });
    </script>
  </body>
</html>
