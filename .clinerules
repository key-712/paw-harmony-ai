# Cline Rules

## ロール定義

あなたはFlutterのエキスパートエンジニアとして、以下のルールとプロジェクトの既存の規約を厳密に遵守し、高品質なコードとドキュメントを提供してください。

## 参照ドキュメント
実装に着手する前に、以下のドキュメントを必ず確認し、内容を完全に理解してください。
- `docs/app_concept.md`: アプリのコンセプトと提供価値について定義されています。
- `docs/requirements.md`: アプリの機能要件と非機能要件が定義されています。

## プロジェクトの技術スタック

### フレームワーク・ライブラリ
- **Flutter**: stable バージョン
- **状態管理**: Riverpod（hooks_riverpod）と Flutter Hooks（flutter_hooks）の組み合わせ
- **ルーティング**: GoRouter
- **国際化**: flutter_localizations
- **データ永続化**: SharedPreferences
- **バックエンド**: Firebase（Firestore, Authentication, Analytics, Crashlytics 等）
- **広告**: Google Mobile Ads
- **課金**: RevenueCat（purchases_flutter）
- **通知**: Firebase Cloud Messaging

### 開発ツール
- **コード生成**: build_runner, freezed, json_serializable
- **リント**: flutter_lints, pedantic_mono
- **アイコン生成**: flutter_launcher_icons
- **スプラッシュ画面**: flutter_native_splash

## 期待する回答

- 実装コードは省略せず、完全な形で提供してください。
- TypeScriptの型定義も含めてください。
- セキュリティのベストプラクティスに従った実装をしてください。
- レスポンシブデザインを考慮したUI/UX提案をしてください。
- 日本語での詳細な説明を加えてください。

## セキュリティ

### 機密ファイル
以下のファイルの読み取りと変更を禁止します：
- .env ファイル
- APIキー、トークン、認証情報を含むすべてのファイル

### セキュリティ対策
- 機密ファイルを絶対にコミットしないでください。
- シークレット情報は環境変数を使用してください。
- ログや出力に認証情報を含めないでください。

## コーディング規約

### 一般的なルール
- `analysis_options.yaml`で設定された静的解析ルールに従い、警告が出ないようにコーディングしてください。
- 括弧が連続する場合は間にコンマを入れて改行させてください。
- `EdgeInsets`クラスを使う際、プロパティが1つの場合は1行にし、それ以外は改行させてください。
- `if`文の中身が1行で短い場合は、1行にまとめてください（ただし、1行の文字数制限に引っかかる場合は例外）。
- 1行で済む`return`文はアロー関数を使用してください。
- JavaScript実行周りでは`try-catch`文を使用してください。

### 余白
- `SizedBox`ではなく、`hSpace`、`wSpace`というコンポーネントを使用してください。
- 余白は極力`margin`ではなく`padding`で対応してください。

### カラーの使用
- 基本カラーは`colors.dart`で提供されているものを使用することを推奨します。
- カスタムカラーは`app_colors.dart`で定義した色を使用し、ライトモードとダークモードの両方に対応できるようにしてください。
- マテリアルコンポーネントのカラー設定は`app_theme.dart`で`ThemeData`を定義してください。

### Import
- 相対パスで記述し、同じファイルを二重でインポートしないようにしてください。
- インポート順序は以下の通りにしてください：
    1. Dartの標準ライブラリ
    2. サードパーティライブラリ
    3. プロジェクト内の相対インポート（`import/`ディレクトリ経由）

### 変数名
- 外部クラスやファイルからアクセスさせない場合は先頭にアンダースコアを付与し、プライベート変数にしてください。

### 命名規則
- クラス名: `PascalCase`（例: `CustomButton`, `UserProfile`）
- 変数・メソッド名: `camelCase`（例: `userName`, `fetchData`）
- ファイル名: `snake_case`（例: `custom_button.dart`）
- ディレクトリ名: `snake_case`（例: `component`, `screen`, `setting`）
- プライベートメンバー: `_`プレフィックス
- ファイル名に`provider`は付けないでください（例: `layer_1_web_view_contents.dart`）。
- ファイル名に`StateNotifier`は付けてください（例: `layer_1_web_view_state_notifier.dart`）。
- リスト形式で一覧を表示させるファイルの場合は`XX_list.dart`のようにし、具体度を上げてください。

### ファイル構造
- 1ファイルにつき1つの主要クラスを配置してください。
- 関連する小さなクラスやenumは同じファイルに配置可能です。
- 1フォルダに目安として10ファイル以上存在する場合は、フォルダで分割することを検討してください。
- フォルダ名は単数形にしてください。
- フォルダ名に省略形は使用して構いません。ただし、一般的に使用されている省略形のみ許容します。

## コンポーネント設計と実装の規約

### ウィジェット構造
- 複雑なウィジェットは小さなウィジェットに分割してください。
- `StatelessWidget`を優先し、必要な場合のみ`StatefulWidget`を使用してください。
- `HookConsumerWidget`を基底クラスとして使用してください。
- Riverpodを使用した状態管理を推奨します。

### レイアウト
- ハードコードされた数値の代わりに`utility/space.dart`の定数を使用してください。
- レスポンシブデザインには`utility/media_query.dart`を使用してください。

### コンポーネント命名パターン
- 画面: 〇〇 `Screen`（例: `HomeScreen`, `SettingsScreen`）
- コンポーネント: 機能を表す名前（例: `CustomButton`, `LoadingDialog`）
- ヘッダー: 〇〇 `Header`（例: `BaseHeader`, `BackIconHeader`）
- 原則、`lib/components`配下に作成してください。
- 作成時には関数ではなくクラスで作成してください。
- Widgetbookに載せるため、UseCaseも作成してください。

### ボタンコンポーネントの使用
- `TextButton`や`ElevatedButton`を直接使用せず、`lib/component/button`配下の専用ボタンコンポーネントを使用してください。
- 利用可能なボタンコンポーネント：
  - `PrimaryButton`: 主要なアクション用
  - `SecondaryButton`: 二次的なアクション用
  - `CancelButton`: キャンセルアクション用
  - `DialogPrimaryButton`: ダイアログ内の主要アクション用
  - `DialogSecondaryButton`: ダイアログ内の二次的アクション用
- 新しいボタンコンポーネントが必要な場合は、既存のパターンに従って`lib/component/button`配下に作成してください。

### スナックバーコンポーネントの使用
- `ScaffoldMessenger.of(context).showSnackBar`を直接使用せず、`lib/component/snackbar`配下の専用スナックバーコンポーネントを使用してください。
- 利用可能なスナックバーコンポーネント：
  - `showSnackBar`: 成功メッセージ用（緑色の背景）
  - `showAlertSnackBar`: エラーメッセージ用（赤色の背景）
- 新しいスナックバーコンポーネントが必要な場合は、既存のパターンに従って`lib/component/snackbar`配下に作成してください。

### 画面遷移の使用
- `Navigator.of(context).push`や`Navigator.of(context).pushReplacement`を直接使用せず、`lib/route/route.dart`で定義されたGoRouterベースのルートクラスを使用してください。
- 利用可能なルートクラス：
  - `WalkThroughRoute`: ウォークスルー画面
  - `BaseScreenRoute`: ベース画面
  - `PushScreenRoute`: プッシュ通知設定画面
  - `ContactScreenRoute`: お問い合わせ画面
  - `RequestScreenRoute`: ご意見・ご要望画面
  - `RecommendAppScreenRoute`: オススメアプリ画面
  - `LanguageSettingScreenRoute`: 言語設定画面
  - `SettingScreenRoute`: 設定画面
  - `LoginRoute`: ログイン画面
  - `SignUpRoute`: 新規登録画面
  - `PasswordResetRoute`: パスワードリセット画面
  - `HomeRoute`: ホーム画面
  - `DogProfileRoute`: 犬プロフィール画面
  - `MusicPlayerRoute`: 音楽再生画面（パラメータ付き）
  - `MyPageRoute`: マイページ画面
  - `SubscriptionRoute`: サブスクリプション画面
- 正しい例: `const LoginRoute().go(context)` または `const MusicPlayerRoute(musicUrl: url).push<void>(context)`
- 間違った例: `Navigator.of(context).push(MaterialPageRoute(builder: (context) => LoginScreen()))`
- 新しい画面を追加する場合は、`lib/route/route.dart`にルートクラスを定義してください。

## 状態管理

### Riverpod + Flutter Hooks
- 主要な状態管理にRiverpodとFlutter Hooksを組み合わせて使用してください。
- グローバル状態は`Provider`で管理してください（例: `appThemeProvider`, `userStateProvider`）。
- ローカル状態は`useState`や`useTextEditingController`などのHooksで管理してください。

### 状態の分離パターン
- 読み取り専用の状態: `ref.watch(provider)`
- 状態の更新: `ref.watch(provider.notifier)`
- コンポーネント内状態管理:
    - 一時的な状態（検索結果など）は`useState`で管理してください。
    - フォーム状態は`TextEditingController`で管理してください。

### プロバイダーの種類
- 複雑な状態には`StateNotifier`を使用してください。
- 単純な状態には`Provider`を使用してください。
- 非同期データの取得には`FutureProvider`または`StreamProvider`を使用してください。

## エラーハンドリング

### 例外処理
- `try-catch`文を使用する際は、必ず例外の型を明示してください（例: `on Exception catch (e)`）。`catch (e)` のような汎用的な例外捕捉は、意図しないエラーまで握りつぶしてしまう可能性があるため原則禁止します。
- APIエラーは適切なエラーハンドリングを使用してください。
- 認証エラーは専用のハンドリングを使用してください。
- ネットワークエラーは`use_network_check.dart`を使用してください。

### ログ記録
- `debugPrint`の使用は禁止します。ログ出力には必ず`utility/logger/logger.dart`で定義されている`logger`インスタンスを使用してください。
- 開発環境では詳細なログを記録し、本番環境では最小限のログを記録してください。
- ログパラメータは`utility/format_log_parameters.dart`でフォーマットしてください。

## テスト

### 単体テスト
- ビジネスロジックとユーティリティ関数には単体テストを作成してください。
- テストファイルは対応するソースファイルと同じディレクトリ構造に配置してください。
- テストファイル名は`*_test.dart`の形式にしてください。

### モック
- 外部依存関係のモックには`mockito`または`mocktail`を使用してください。
- テスト用のモックデータは`test/mock_data/`ディレクトリに配置してください。

## コミットメッセージ規約

### 1. 基本構造

```
<type>(<scope>): <subject>

<body>

<footer>

# プロンプト履歴
<prompt_history>
```

### 2. 各要素の説明

#### Type
- `feature`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響を与えない変更（空白、フォーマット、セミコロンの追加など）
- `refactor`: バグ修正や機能追加のないコードの変更
- `test`: テストの追加・修正
- `chore`: ビルドプロセスやドキュメント生成などの補助ツールやライブラリの変更

#### Scope
- 変更の影響範囲を示す。
- 複数のスコープがある場合はカンマで区切る。
- 全体的な変更の場合は省略可能。

#### Subject
- 変更内容を簡潔に要約。

#### Body
- 変更の詳細な説明。
- 改行して複数行で記述可能。
- なぜその変更が必要だったのかの背景も含める。
- 72文字で改行。

#### Prompt History
- ユーザーが指示したプロンプトの履歴を記載。
- プロンプトに関連する追加のコンテキスト情報も含める。

### 3. コミットメッセージの例

```
feature(reviews): ドキュメントレビュー承認機能を追加

- レビュー承認ワークフローを実装
- 承認条件のバリデーションを追加
- 承認履歴の追跡機能を実装

# プロンプト履歴
1. Q: 投稿機能の実装をお願いします
   A: 投稿を実装し、投稿条件のバリデーションを追加

2. Q: 投稿履歴の追加もお願いします
   A: 投稿履歴の追跡機能を実装し、履歴データの保存と表示機能を追加
```

### 4. コミットメッセージコマンドの制限事項
- コミットメッセージを作成した場合、コマンドの実行は行わない。
- 作成したメッセージ内容のみを回答として提供する。
- コマンドの実行は必ずユーザーが手動で行う。

### 5. コミットメッセージの作成手順
1. コード変更後の確認を実施する
   - `yarn run build` でビルドが成功することを確認
   - `yarn run test:unit` で変更したファイルのテストが成功することを確認

2. `commit_message.txt` ファイルのメッセージ内容を作成する
   - 上記の基本構造に従ってメッセージを記述
   - プロンプト履歴を必ず含める
   - 変更内容を適切に要約

3. 作成したメッセージ内容を回答として提供する
   - コマンドの実行は行わない
   - ユーザーが手動でコミットを実行する

### 6. 注意事項
- 1つのコミットでは1つの論理的な変更のみを含める。
- 複数の変更がある場合は複数のコミットに分割する。
- コミットメッセージは日本語で記述可能。
- プロンプト履歴は変更の追跡可能性のために必ず含める。
- `commit_message.txt` は一時的なファイルとして使用する。

## プルリクエスト作成規約

### 1. 基本ルール
- ベースブランチは`development`に固定。
- タイトルとボディは日本語で記述。

### 2. タイトル・ボディの作成

#### タイトル
- ブランチに含まれるコミット内容を簡潔に要約。
- フォーマット: `コミットタイプ: 変更内容の要約`
- 例：`feature: ドキュメントレビュー承認機能の追加`

#### ボディ
- コミット履歴から主要な変更点を抽出してリスト形式で記述。
- 変更の背景や目的を含める。
- テスト実行結果や動作確認結果を記載。

### 3. プルリクエストコマンドの制限事項
- プルリクエストコマンドを作成した場合、コマンドの実行は行わない。
- 作成したコマンド内容のみを回答として提供する。
- コマンドの実行は必ずユーザーが手動で行う。

### 4. `gh` コマンドの使用

```bash
# 現在のブランチ名を取得
current_branch=$(git branch --show-current)

# プルリクエスト作成コマンド
gh pr create \
  --base development \
  --head "$current_branch" \
  --title "[コミットタイプ] 変更内容の要約" \
  --body "## 変更内容

- 変更点1
- 変更点2
- 変更点3

## 変更の背景・目的
- 背景の説明
- 目的の説明

## テスト結果
- [ ] ユニットテスト実行済み
- [ ] 動作確認済み
"
```

### 5. レビュー依頼時の注意点
- 特に確認してほしい点を明記。
- コードの複雑な部分には補足説明を追加。

## ナレッジ遵守のルール

### 🚨 最重要事項（絶対遵守）

#### ナレッジルール違反の防止
- 作業開始前に関連する全てのナレッジを読み込み、完全に理解すること。
- 作業中も常にナレッジルールを参照し、違反しないよう注意すること。
- 特に以下のルールは絶対に違反してはならない：
    - CI 待機の禁止（「作業後に CI の完了を待たない事」）
    - `git_update_pr_description`コマンドの使用禁止
    - PR 説明テンプレートの厳密な使用
    - 独自の PR 説明作成の禁止

#### 違反時の対応
- ルール違反を指摘された場合は、即座に認めて謝罪すること。
- 違反した具体的な内容を明確に説明すること。
- 今後の厳密な遵守を約束すること。

### 注意事項
- このルールは例外なく適用される。
- ナレッジルールの遵守は、タスクの技術的な完了よりも優先される。
- ユーザーからの信頼を失わないよう、ルール遵守を最優先とすること。

- コード追加、修正を加えたら`fvm flutter analyze`を実行して、エラーがないか確認する。エラーやinfo,warningがあったら、エラーを修正すること。
- `Missing documentation for a public member. Try adding documentation for the member.` の対策を必ず行うこと。

- パブリックメンバーには必ずdartdoc形式（///）で日本語のドキュメントコメントを記述すること。
- ジェネリクスや型推論が必要な箇所では、型を明示して推論エラーを防ぐこと。
- TODOコメントは必ず「// TODO(担当者名): ...」のFlutterスタイルで記述すること。
- 非同期処理でBuildContextを使用する場合は、context.mounted等で安全性を必ず確認すること。

### Importルール
- プロジェクト内のインポートは必ず`import/`ディレクトリ経由で行うこと。
- 相対パスでの直接インポート（例: `import '../model/dog_profile.dart'`）は禁止すること。
- 正しい例: `import '../../import/component.dart';`
- 間違った例: `import '../model/dog_profile.dart';`

### Exportルール
- 新規ファイルを追加した際は、対応する`lib/import/`ディレクトリ内のファイルにexport文を追加すること。
- 例: `lib/component/button/cancel_button.dart`を追加した場合、`lib/import/component.dart`に`export '../component/button/cancel_button.dart';`を追加すること。
- これにより、他のファイルから`import '../../import/component.dart';`でインポートできるようになる。

### テキストウィジェットルール
- テキスト表示には必ず`ThemeText`を使用すること。
- 通常の`Text`ウィジェットの使用は禁止すること。
- 正しい例: `ThemeText(text: '表示するテキスト')`
- 間違った例: `Text('表示するテキスト')`

### AppBar使用ルール
- 画面（screen）配下では直接`AppBar`を使用せず、`lib/component/header`配下のコンポーネントを使用すること。
- 利用可能なヘッダーコンポーネント：
  - `BaseHeader`: 基本的なヘッダー（戻るボタンなし）
  - `BackIconHeader`: 戻るアイコンとタイトルがあるヘッダー
  - `IconActionsHeader`: アクションボタンがあるヘッダー
  - `TextActionsHeader`: テキストアクションボタンがあるヘッダー
  - `OnlyBackIconHeader`: 戻るアイコンだけのヘッダー
- 正しい例: `appBar: const BackIconHeader(title: '画面タイトル')`
- 間違った例: `appBar: AppBar(title: Text('画面タイトル'))`
